const DataManager = {
STORAGE_KEY: 'wedding_recipients_data',
BACKUP_KEY: 'wedding_recipients_backup',
STATUS: {
PENDING: 'pending',      // å¾…å¤„ç†
SHIPPED: 'shipped',      // å·²å‘è´§
RECEIVED: 'received'     // å·²ç­¾æ”¶
},
RELATIONSHIP_MAP: {
'family': 'å®¶äºº',
'friend': 'æœ‹å‹',
'colleague': 'åŒäº‹',
'relative': 'äº²æˆš',
'other': 'å…¶ä»–'
},
generateId() {
const now = new Date();
const dateStr = Utils.formatDate(now, 'YYYYMMDD');
const allRecipients = this.getAllRecipients();
const todayRecipients = allRecipients.filter(r => {
const recordDate = Utils.formatDate(new Date(r.submit_time), 'YYYYMMDD');
return recordDate === dateStr;
});
const sequence = String(todayRecipients.length + 1).padStart(3, '0');
return `R${dateStr}_${sequence}`;
},
getDeviceInfo() {
const ua = navigator.userAgent;
let deviceType = 'Desktop';
if (/Mobile|Android|iPhone|iPad|iPod/.test(ua)) {
if (/iPad/.test(ua)) {
deviceType = 'iPad';
} else if (/iPhone/.test(ua)) {
deviceType = 'iPhone';
} else if (/Android/.test(ua)) {
deviceType = 'Android';
} else {
deviceType = 'Mobile';
}
}
const browser = Utils.getBrowser();
return `${deviceType} | ${browser}`;
},
getIpAddress() {
return 'Client-Side';
},
saveRecipient(data) {
try {
if (!data.name || !data.phone) {
return {
success: false,
message: 'å§“åå’Œæ‰‹æœºå·ä¸ºå¿…å¡«é¡¹',
data: null
};
}
const allRecipients = this.getAllRecipients();
const phoneExists = allRecipients.some(r => {
const existingPhone = r.phone.replace(/\*/g, '');
const newPhone = data.phone;
return existingPhone.substring(0, 3) === newPhone.substring(0, 3) &&
existingPhone.substring(existingPhone.length - 4) === newPhone.substring(newPhone.length - 4);
});
if (phoneExists) {
return {
success: false,
message: 'è¯¥æ‰‹æœºå·å·²ç»æäº¤è¿‡é¢†å–ä¿¡æ¯',
data: null
};
}
const recipient = {
id: this.generateId(),
name: data.name,
phone: FormValidator.maskPhone(data.phone), // è„±æ•å¤„ç†
phone_raw: data.phone, // ä¿ç•™åŸå§‹å·ç ç”¨äºé€šçŸ¥ï¼ˆå®é™…é¡¹ç›®ä¸­åº”åŠ å¯†å­˜å‚¨ï¼‰
wechat: data.wechat || '',
address: {
province: data.province || '',
city: data.city || '',
district: data.district || '',
detail: data.address || '',
zipcode: data.zipcode || '',
full: `${data.province || ''} ${data.city || ''} ${data.district || ''} ${data.address || ''}`.trim()
},
relation: data.relationship || 'other',
relation_text: this.RELATIONSHIP_MAP[data.relationship] || 'å…¶ä»–',
delivery_time: data.deliveryTime || 'anytime',
blessing: data.message || '',
status: this.STATUS.PENDING,
status_text: 'å¾…å¤„ç†',
submit_time: new Date().toISOString(),
submit_time_formatted: Utils.formatDate(new Date(), 'YYYY-MM-DD HH:mm:ss'),
ip_address: this.getIpAddress(),
device_info: this.getDeviceInfo(),
created_at: new Date().toISOString(),
updated_at: new Date().toISOString()
};
allRecipients.unshift(recipient); // æ·»åŠ åˆ°æ•°ç»„å¼€å¤´ï¼ˆæœ€æ–°çš„åœ¨å‰ï¼‰
if (!this.saveToStorage(allRecipients)) {
return {
success: false,
message: 'å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œä¿å­˜å¤±è´¥',
data: null
};
}
this.createBackup(allRecipients);
this.saveLastSubmission(recipient);
return {
success: true,
message: 'ä¿å­˜æˆåŠŸ',
data: recipient
};
} catch (error) {
console.error('Save recipient error:', error);
return {
success: false,
message: 'ç³»ç»Ÿé”™è¯¯ï¼Œä¿å­˜å¤±è´¥',
data: null
};
}
},
addRecipient(data) {
return this.saveRecipient(data);
},
getAllRecipients() {
return Utils.storage.get(this.STORAGE_KEY, []);
},
getRecipientById(id) {
const recipients = this.getAllRecipients();
return recipients.find(r => r.id === id) || null;
},
updateStatus(id, status) {
try {
const recipients = this.getAllRecipients();
const index = recipients.findIndex(r => r.id === id);
if (index === -1) {
console.warn('Record not found:', id);
return false;
}
if (!Object.values(this.STATUS).includes(status)) {
console.warn('Invalid status:', status);
return false;
}
recipients[index].status = status;
recipients[index].status_text = this.getStatusText(status);
recipients[index].updated_at = new Date().toISOString();
if (status === this.STATUS.SHIPPED && !recipients[index].shipped_at) {
recipients[index].shipped_at = new Date().toISOString();
}
if (status === this.STATUS.RECEIVED && !recipients[index].received_at) {
recipients[index].received_at = new Date().toISOString();
}
return this.saveToStorage(recipients);
} catch (error) {
console.error('Update status error:', error);
return false;
}
},
toggleStatus(id) {
const recipient = this.getRecipientById(id);
if (!recipient) return false;
const newStatus = recipient.status === this.STATUS.PENDING
? this.STATUS.SHIPPED
: this.STATUS.PENDING;
return this.updateStatus(id, newStatus);
},
updateRecipient(id, updates) {
try {
const recipients = this.getAllRecipients();
const index = recipients.findIndex(r => r.id === id);
if (index === -1) {
return false;
}
recipients[index] = {
...recipients[index],
...updates,
updated_at: new Date().toISOString()
};
return this.saveToStorage(recipients);
} catch (error) {
console.error('Update recipient error:', error);
return false;
}
},
deleteRecipient(id) {
try {
const recipients = this.getAllRecipients();
const filteredRecipients = recipients.filter(r => r.id !== id);
if (filteredRecipients.length === recipients.length) {
console.warn('Record not found:', id);
return false;
}
return this.saveToStorage(filteredRecipients);
} catch (error) {
console.error('Delete recipient error:', error);
return false;
}
},
batchDelete(ids) {
let success = 0;
let failed = 0;
ids.forEach(id => {
if (this.deleteRecipient(id)) {
success++;
} else {
failed++;
}
});
return { success, failed };
},
searchRecipients(keyword) {
if (!keyword || !keyword.trim()) {
return this.getAllRecipients();
}
const recipients = this.getAllRecipients();
const lowerKeyword = keyword.toLowerCase().trim();
return recipients.filter(r => {
if (r.name && r.name.toLowerCase().includes(lowerKeyword)) {
return true;
}
if (r.phone && r.phone.includes(lowerKeyword)) {
return true;
}
if (r.wechat && r.wechat.toLowerCase().includes(lowerKeyword)) {
return true;
}
if (r.address && r.address.full && r.address.full.toLowerCase().includes(lowerKeyword)) {
return true;
}
if (r.id && r.id.toLowerCase().includes(lowerKeyword)) {
return true;
}
return false;
});
},
filterByStatus(status) {
const recipients = this.getAllRecipients();
return recipients.filter(r => r.status === status);
},
filterByDateRange(startDate, endDate) {
const recipients = this.getAllRecipients();
return recipients.filter(r => {
const submitDate = new Date(r.submit_time);
return submitDate >= startDate && submitDate <= endDate;
});
},
getStatistics() {
const recipients = this.getAllRecipients();
const total = recipients.length;
const pending = recipients.filter(r => r.status === this.STATUS.PENDING).length;
const shipped = recipients.filter(r => r.status === this.STATUS.SHIPPED).length;
const received = recipients.filter(r => r.status === this.STATUS.RECEIVED).length;
const today = recipients.filter(r => Utils.isToday(r.submit_time)).length;
const weekAgo = new Date();
weekAgo.setDate(weekAgo.getDate() - 7);
const thisWeek = recipients.filter(r => new Date(r.submit_time) >= weekAgo).length;
const monthAgo = new Date();
monthAgo.setMonth(monthAgo.getMonth() - 1);
const thisMonth = recipients.filter(r => new Date(r.submit_time) >= monthAgo).length;
const relationStats = {};
recipients.forEach(r => {
const relation = r.relation_text || 'æœªçŸ¥';
relationStats[relation] = (relationStats[relation] || 0) + 1;
});
const provinceStats = {};
recipients.forEach(r => {
const province = r.address?.province || 'æœªçŸ¥';
provinceStats[province] = (provinceStats[province] || 0) + 1;
});
const cityStats = {};
recipients.forEach(r => {
const city = r.address?.city || 'æœªçŸ¥';
cityStats[city] = (cityStats[city] || 0) + 1;
});
const topCities = Object.entries(cityStats)
.sort((a, b) => b[1] - a[1])
.slice(0, 10);
return {
total,
pending,
shipped,
received,
processed: shipped + received, // å·²å¤„ç†ï¼ˆå·²å‘è´§+å·²ç­¾æ”¶ï¼‰
today,
thisWeek,
thisMonth,
relationStats,
provinceStats,
cityStats: Object.fromEntries(topCities),
completionRate: total > 0 ? ((shipped + received) / total * 100).toFixed(1) : 0
};
},
getStatusText(status) {
const statusMap = {
[this.STATUS.PENDING]: 'å¾…å¤„ç†',
[this.STATUS.SHIPPED]: 'å·²å‘è´§',
[this.STATUS.RECEIVED]: 'å·²ç­¾æ”¶'
};
return statusMap[status] || 'æœªçŸ¥';
},
saveToStorage(recipients) {
return Utils.storage.set(this.STORAGE_KEY, recipients);
},
createBackup(recipients) {
try {
const dataToBackup = recipients || this.getAllRecipients();
const backup = {
data: dataToBackup,
backupTime: new Date().toISOString(),
version: '1.0',
total: dataToBackup.length
};
return Utils.storage.set(this.BACKUP_KEY, backup);
} catch (error) {
console.error('Create backup error:', error);
return false;
}
},
restoreFromBackup() {
try {
const backup = Utils.storage.get(this.BACKUP_KEY);
if (!backup || !backup.data) {
console.warn('No backup found');
return false;
}
return this.saveToStorage(backup.data);
} catch (error) {
console.error('Restore from backup error:', error);
return false;
}
},
clearAll(createBackup = true) {
try {
if (createBackup) {
this.createBackup();
}
Utils.storage.remove(this.STORAGE_KEY);
Utils.storage.remove(CONFIG.STORAGE_KEYS.LAST_SUBMISSION);
return true;
} catch (error) {
console.error('Clear all error:', error);
return false;
}
},
exportToJson() {
const recipients = this.getAllRecipients();
const data = {
exportedAt: new Date().toISOString(),
exportedBy: CONFIG.COUPLE.FULL_NAME,
version: '1.0',
total: recipients.length,
statistics: this.getStatistics(),
recipients: recipients
};
return JSON.stringify(data, null, 2);
},
exportToCsv() {
const recipients = this.getAllRecipients();
const headers = [
'åºå·',
'è®°å½•ID',
'å§“å',
'æ‰‹æœºå·',
'å¾®ä¿¡å·',
'å…³ç³»',
'çœä»½',
'åŸå¸‚',
'åŒºå¿',
'è¯¦ç»†åœ°å€',
'é‚®æ”¿ç¼–ç ',
'æœŸæœ›é…é€æ—¶é—´',
'ç¥ç¦ç•™è¨€',
'çŠ¶æ€',
'æäº¤æ—¶é—´',
'è®¾å¤‡ä¿¡æ¯'
];
const rows = recipients.map((r, index) => [
index + 1,
r.id,
r.name,
r.phone,
r.wechat || '-',
r.relation_text,
r.address?.province || '-',
r.address?.city || '-',
r.address?.district || '-',
r.address?.detail || '-',
r.address?.zipcode || '-',
r.delivery_time || '-',
r.blessing || '-',
r.status_text,
r.submit_time_formatted || Utils.formatDate(r.submit_time),
r.device_info || '-'
]);
const escapeCsvField = (field) => {
const str = String(field);
if (str.includes(',') || str.includes('"') || str.includes('\n')) {
return `"${str.replace(/"/g, '""')}"`;
}
return str;
};
const csvContent = [
headers.map(escapeCsvField).join(','),
...rows.map(row => row.map(escapeCsvField).join(','))
].join('\n');
return '\uFEFF' + csvContent;
},
importFromJson(jsonString) {
try {
const data = JSON.parse(jsonString);
if (!data.recipients || !Array.isArray(data.recipients)) {
return {
success: false,
message: 'æ— æ•ˆçš„æ•°æ®æ ¼å¼',
imported: 0
};
}
this.createBackup();
const existing = this.getAllRecipients();
let imported = 0;
data.recipients.forEach(recipient => {
const exists = existing.some(r => r.id === recipient.id);
if (!exists) {
existing.push(recipient);
imported++;
}
});
if (this.saveToStorage(existing)) {
return {
success: true,
message: `æˆåŠŸå¯¼å…¥ ${imported} æ¡è®°å½•`,
imported: imported
};
} else {
return {
success: false,
message: 'ä¿å­˜å¤±è´¥',
imported: 0
};
}
} catch (error) {
console.error('Import from JSON error:', error);
return {
success: false,
message: 'å¯¼å…¥å¤±è´¥ï¼š' + error.message,
imported: 0
};
}
},
saveLastSubmission(recipient) {
try {
const lastSubmission = {
name: recipient.name,
phone: recipient.phone,
address: recipient.address,
message: recipient.blessing,
submit_time: recipient.submit_time_formatted
};
Utils.storage.set(CONFIG.STORAGE_KEYS.LAST_SUBMISSION, lastSubmission);
} catch (error) {
console.error('Save last submission error:', error);
}
},
getStorageSize() {
return Utils.storage.getSize();
},
getStorageUsage() {
const size = this.getStorageSize();
const limit = 5 * 1024 * 1024; // 5MBï¼ˆå¤§å¤šæ•°æµè§ˆå™¨çš„LocalStorageé™åˆ¶ï¼‰
return (size / limit * 100).toFixed(2);
}
};
if (typeof module !== 'undefined' && module.exports) {
module.exports = DataManager;
}
console.log('%cğŸ’¾ Data Manager Loaded', 'color: #4CAF50; font-size: 12px;');
if (typeof window !== 'undefined') {
window.addEventListener('load', function() {
const stats = DataManager.getStatistics();
console.log(`%cğŸ“Š å½“å‰è®°å½•: ${stats.total} æ¡ | ä»Šæ—¥æ–°å¢: ${stats.today} æ¡`, 'color: #2196F3; font-size: 11px;');
});
}
