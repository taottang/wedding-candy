const Utils = {
formatDate(date, format = 'YYYY-MM-DD HH:mm:ss') {
const d = new Date(date);
if (isNaN(d.getTime())) {
console.warn('Invalid date:', date);
return '-';
}
const year = d.getFullYear();
const month = String(d.getMonth() + 1).padStart(2, '0');
const day = String(d.getDate()).padStart(2, '0');
const hours = String(d.getHours()).padStart(2, '0');
const minutes = String(d.getMinutes()).padStart(2, '0');
const seconds = String(d.getSeconds()).padStart(2, '0');
return format
.replace('YYYY', year)
.replace('MM', month)
.replace('DD', day)
.replace('HH', hours)
.replace('mm', minutes)
.replace('ss', seconds);
},
isToday(date) {
const d = new Date(date);
const today = new Date();
return d.getDate() === today.getDate() &&
d.getMonth() === today.getMonth() &&
d.getFullYear() === today.getFullYear();
},
getDaysBetween(startDate, endDate) {
const start = new Date(startDate);
const end = new Date(endDate);
const diff = Math.abs(end - start);
return Math.ceil(diff / (1000 * 60 * 60 * 24));
},
getRelativeTime(date) {
const now = new Date();
const target = new Date(date);
const diff = Math.floor((now - target) / 1000); // Áßí
if (diff < 60) return 'ÂàöÂàö';
if (diff < 3600) return `${Math.floor(diff / 60)}ÂàÜÈíüÂâç`;
if (diff < 86400) return `${Math.floor(diff / 3600)}Â∞èÊó∂Ââç`;
if (diff < 2592000) return `${Math.floor(diff / 86400)}Â§©Ââç`;
return this.formatDate(date, 'YYYY-MM-DD');
},
formatPhone(phone) {
if (!phone || phone.length !== 11) {
return phone;
}
return phone.replace(/(\d{3})(\d{4})(\d{4})/, '$1****$3');
},
escapeHtml(text) {
const map = {
'&': '&amp;',
'<': '&lt;',
'>': '&gt;',
'"': '&quot;',
"'": '&#039;'
};
return String(text).replace(/[&<>"']/g, m => map[m]);
},
truncate(str, length = 50, suffix = '...') {
if (!str || str.length <= length) {
return str;
}
return str.substring(0, length) + suffix;
},
normalizeWhitespace(str) {
return str.trim().replace(/\s+/g, ' ');
},
generateId(prefix = '') {
const timestamp = Date.now().toString(36);
const randomStr = Math.random().toString(36).substr(2, 9);
const id = timestamp + randomStr;
return prefix ? `${prefix}_${id}` : id;
},
deepClone(obj) {
if (obj === null || typeof obj !== 'object') {
return obj;
}
if (obj instanceof Date) {
return new Date(obj.getTime());
}
if (obj instanceof Array) {
return obj.map(item => this.deepClone(item));
}
const clonedObj = {};
for (const key in obj) {
if (obj.hasOwnProperty(key)) {
clonedObj[key] = this.deepClone(obj[key]);
}
}
return clonedObj;
},
deepMerge(target, ...sources) {
if (!sources.length) return target;
const source = sources.shift();
if (this.isObject(target) && this.isObject(source)) {
for (const key in source) {
if (this.isObject(source[key])) {
if (!target[key]) Object.assign(target, { [key]: {} });
this.deepMerge(target[key], source[key]);
} else {
Object.assign(target, { [key]: source[key] });
}
}
}
return this.deepMerge(target, ...sources);
},
isObject(item) {
return item && typeof item === 'object' && !Array.isArray(item);
},
debounce(func, wait = 300, immediate = false) {
let timeout;
return function executedFunction(...args) {
const context = this;
const later = () => {
timeout = null;
if (!immediate) func.apply(context, args);
};
const callNow = immediate && !timeout;
clearTimeout(timeout);
timeout = setTimeout(later, wait);
if (callNow) func.apply(context, args);
};
},
throttle(func, limit = 300) {
let inThrottle;
let lastResult;
return function(...args) {
const context = this;
if (!inThrottle) {
lastResult = func.apply(context, args);
inThrottle = true;
setTimeout(() => inThrottle = false, limit);
}
return lastResult;
};
},
storage: {
set(key, value) {
try {
const serializedValue = JSON.stringify(value);
localStorage.setItem(key, serializedValue);
return true;
} catch (error) {
console.error('Storage set error:', error);
if (error.name === 'QuotaExceededError') {
console.error('Storage quota exceeded');
}
return false;
}
},
get(key, defaultValue = null) {
try {
const item = localStorage.getItem(key);
return item ? JSON.parse(item) : defaultValue;
} catch (error) {
console.error('Storage get error:', error);
return defaultValue;
}
},
remove(key) {
try {
localStorage.removeItem(key);
return true;
} catch (error) {
console.error('Storage remove error:', error);
return false;
}
},
clear() {
try {
localStorage.clear();
return true;
} catch (error) {
console.error('Storage clear error:', error);
return false;
}
},
has(key) {
return localStorage.getItem(key) !== null;
},
getSize() {
let total = 0;
for (let key in localStorage) {
if (localStorage.hasOwnProperty(key)) {
total += localStorage[key].length + key.length;
}
}
return total;
},
},
toast(message, type = 'info', duration = 3000) {
const existingToast = document.querySelector('.custom-toast');
if (existingToast) {
existingToast.remove();
}
const toast = document.createElement('div');
toast.className = `custom-toast toast-${type}`;
const icons = {
success: '‚úì',
error: '‚úï',
warning: '‚ö†',
info: '‚Ñπ'
};
toast.innerHTML = `
<span class="toast-icon">${icons[type] || icons.info}</span>
<span class="toast-message">${this.escapeHtml(message)}</span>
`;
if (!document.querySelector('#toast-style')) {
const style = document.createElement('style');
style.id = 'toast-style';
style.textContent = `
.custom-toast {
position: fixed;
top: 20px;
left: 50%;
transform: translateX(-50%);
background: white;
padding: 15px 25px;
border-radius: 10px;
box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
display: flex;
align-items: center;
gap: 10px;
z-index: 10000;
animation: toastSlideIn 0.3s ease;
min-width: 250px;
max-width: 500px;
}
@keyframes toastSlideIn {
from {
opacity: 0;
transform: translateX(-50%) translateY(-20px);
}
to {
opacity: 1;
transform: translateX(-50%) translateY(0);
}
}
.custom-toast.toast-success { border-left: 4px solid #4CAF50; }
.custom-toast.toast-error { border-left: 4px solid #f44336; }
.custom-toast.toast-warning { border-left: 4px solid #ff9800; }
.custom-toast.toast-info { border-left: 4px solid #2196F3; }
.toast-icon {
font-size: 1.2rem;
font-weight: bold;
}
.toast-success .toast-icon { color: #4CAF50; }
.toast-error .toast-icon { color: #f44336; }
.toast-warning .toast-icon { color: #ff9800; }
.toast-info .toast-icon { color: #2196F3; }
.toast-message {
color: #333;
font-size: 0.95rem;
}
`;
document.head.appendChild(style);
}
document.body.appendChild(toast);
setTimeout(() => {
toast.style.animation = 'toastSlideIn 0.3s ease reverse';
setTimeout(() => toast.remove(), 300);
}, duration);
},
confirm(message) {
return window.confirm(message);
},
alert(message) {
window.alert(message);
},
formatNumber(num) {
return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
},
random(min, max) {
return Math.floor(Math.random() * (max - min + 1)) + min;
},
unique(arr) {
return [...new Set(arr)];
},
groupBy(arr, fn) {
return arr.reduce((result, item) => {
const key = fn(item);
(result[key] = result[key] || []).push(item);
return result;
}, {});
},
isMobile() {
return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
},
getBrowser() {
const ua = navigator.userAgent;
if (ua.indexOf('Chrome') > -1) return 'Chrome';
if (ua.indexOf('Safari') > -1) return 'Safari';
if (ua.indexOf('Firefox') > -1) return 'Firefox';
if (ua.indexOf('Edge') > -1) return 'Edge';
if (ua.indexOf('MSIE') > -1 || ua.indexOf('Trident') > -1) return 'IE';
return 'Unknown';
},
};
if (typeof module !== 'undefined' && module.exports) {
module.exports = Utils;
}
console.log('%cüõ†Ô∏è Utils Library Loaded', 'color: #2196F3; font-size: 12px;');
